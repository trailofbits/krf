#!/usr/bin/env ruby
# frozen_string_literal: true

# codegen for KRF
# Like all code generators, this file is ugly.
# https://filippo.io/linux-syscall-table/

require "yaml"

HEADER = <<~HEADER
  /* WARNING!
   * This file was generated by KRF's codegen.
   * Do not edit it by hand.
   */
HEADER

SYSCALL_SPECS = Dir[File.join(__dir__, "syscalls", "*.yml")]

SYSCALLS = SYSCALL_SPECS.map do |path|
  spec = YAML.safe_load File.read(path)
  [File.basename(path, ".yml"), spec]
end.to_h

SOURCE_DIR = File.expand_path "..", __dir__

def hai(msg)
  STDERR.puts "[codegen] #{msg}"
end

hai "output directory: #{SOURCE_DIR}"

gen_files = {
  krf_x: File.open(File.join(SOURCE_DIR, "krf.gen.x"), "w"),
  syscalls_h: File.open(File.join(SOURCE_DIR, "syscalls.gen.h"), "w"),
  syscalls_x: File.open(File.join(SOURCE_DIR, "syscalls.gen.x"), "w"),
  internal_h: File.open(File.join(SOURCE_DIR, "syscalls", "internal.gen.h"), "w"),
}

gen_files.each_value { |file| file.puts HEADER }

SYSCALLS.each do |call, spec|
  # Each syscall requires code generation in 5 files:
  # 1. krf.gen.x, to tell krf that we're interested in faulting it
  # 2. syscalls.gen.h, to prototype the initial wrapper
  # 3. syscalls.gen.x, to set up the initial wrapper
  # 4. syscalls/internal.gen.h, to prototype the internal wrapper
  # 5. syscalls/<syscall>.gen.c, to set up the actual faulty calls

  nr = spec["nr"] || call

  hai "#{call} (nr: __NR_#{nr})"

  gen_files[:krf_x].puts <<~KRF_X
    krf_faultable_table[__NR_#{nr}] = (void *)&krf_sys_#{call};
  KRF_X

  gen_files[:syscalls_x].puts <<~SYSCALLS_X
    long KRF_DEFINE(#{call})(#{spec["proto"]}) {
      typeof(sys_#{call}) *real_#{call} = (void *)krf_sys_call_table[__NR_#{nr}];

      if (krf_targeted() && (KRF_RNG_NEXT() % krf_probability) == 0) {
        return KRF_SYS_INTERNAL(#{call})(#{spec["parms"]});
      } else {
        return real_#{call}(#{spec["parms"]});
      }
    }
  SYSCALLS_X

  gen_files[:syscalls_h].puts <<~SYSCALLS_H
    KRF_DEFINE_PROTO(#{call});
  SYSCALLS_H

  gen_files[:internal_h].puts <<~INTERNAL_H
    KRF_DEFINE_INTERNAL_PROTO(#{call});
  INTERNAL_H

  syscall_c = File.join(SOURCE_DIR, "syscalls", "#{call}.gen.c")
  File.open(syscall_c, "w") do |file|
    file.puts HEADER
    file.puts <<~SETUP
      #include "internal.h"

      #define KRF_SYS_CALL #{call}
      #define KRF_SYS_PARMS #{spec["proto"]}
      #define KRF_SYS_PARMSX #{spec["parms"]}
    SETUP

    fault_table = []
    spec["errors"].uniq.each do |fault|
      fault_table << "FAULT(#{fault})"

      file.puts <<~FAULT
        DEFINE_FAULT(#{fault}) {
          if (krf_log_faults) {
            printk("faulting #{call} with #{fault}\\n");
          }

          return -#{fault};
        }
      FAULT
    end

    file.puts <<~TRAILER
      static typeof(sys_#{call})(*fault_table[]) = {
        #{fault_table.join ", "}
      };

      // Fault entrypoint.
      long KRF_DEFINE_INTERNAL(#{call})(KRF_SYS_PARMS) {
        return fault_table[KRF_RNG_NEXT() % NFAULTS](KRF_SYS_PARMSX);
      }
    TRAILER
  end
end

gen_files.each_value(&:close)
